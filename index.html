<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÂõæÁâáÊñáÂ≠óÁºñËæëÂô® Pro</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
            max-width: 1200px;
            width: 100%;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }

        .header h1 {
            font-size: 28px;
            margin-bottom: 10px;
        }

        .toolbar {
            background: #f8f9fa;
            padding: 15px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
            border-bottom: 1px solid #dee2e6;
        }

        .tool-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .tool-btn {
            padding: 10px 20px;
            border: 2px solid #dee2e6;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .tool-btn:hover {
            background: #f8f9fa;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .tool-btn.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }
        
        .tool-btn.pen-active {
            background: #28a745;
            color: white;
            border-color: #28a745;
        }

        .color-display {
            width: 40px;
            height: 40px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        #colorPicker {
            position: absolute;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
        }

        .sampled-color-display {
            width: 40px;
            height: 40px;
            border: 2px solid #28a745;
            border-radius: 8px;
            margin-left: 10px;
            position: relative;
        }

        .sampled-color-display::after {
            content: 'ÂèñÊ†∑Ëâ≤';
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            color: #666;
            white-space: nowrap;
        }

        .main-content {
            padding: 20px;
            background: #f8f9fa;
            position: relative;
        }

        .upload-area {
            border: 3px dashed #dee2e6;
            border-radius: 15px;
            padding: 60px 20px;
            text-align: center;
            background: white;
            cursor: pointer;
            transition: all 0.3s;
        }

        .upload-area:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .upload-area h3 {
            color: #495057;
            margin: 20px 0 10px 0;
        }

        #fileInput {
            display: none;
        }

        .canvas-wrapper {
            position: relative;
            width: 100%;
            height: 600px;
            overflow: auto;
            background: #e0e0e0;
            border-radius: 10px;
            border: 2px solid #dee2e6;
            cursor: grab;
        }

        .canvas-wrapper.dragging {
            cursor: grabbing;
        }

        .canvas-container {
            position: absolute;
            display: inline-block;
            border: 2px solid #dee2e6;
            background: white;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            transform-origin: top left;
            transition: none;
        }

        canvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        .zoom-controls {
            position: fixed;
            bottom: 100px;
            right: 20px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 1000;
        }
        
        .zoom-btn {
            width: 40px;
            height: 40px;
            border: 2px solid #dee2e6;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }
        
        .zoom-btn:hover {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }
        
        .text-element {
            position: absolute;
            cursor: move;
            padding: 5px;
            border: 2px dashed transparent;
            user-select: none;
            transition: border-color 0.2s;
        }
        
        .text-element:hover {
            border-color: #667eea;
        }
        
        .text-element.selected {
            border-color: #667eea;
        }
        
        .text-element.editing {
            border-color: #28a745;
            cursor: text;
        }
        
        .resize-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #667eea;
            border: 2px solid white;
            border-radius: 50%;
            cursor: se-resize;
            bottom: -5px;
            right: -5px;
            display: none;
        }
        
        .text-element.selected .resize-handle {
            display: block;
        }

        .zoom-level {
            text-align: center;
            font-size: 14px;
            color: #495057;
            font-weight: bold;
        }

        .color-preview {
            position: fixed;
            width: 150px;
            height: 150px;
            border: 3px solid #667eea;
            border-radius: 10px;
            background: white;
            pointer-events: none;
            z-index: 10000;
            display: none;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .color-preview canvas {
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }

        .color-info {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 5px;
            font-size: 12px;
            text-align: center;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 30px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 500;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .hidden {
            display: none !important;
        }

        .tips {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .tips.show {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üé® ÂõæÁâáÊñáÂ≠óÁºñËæëÂô® Pro</h1>
            <p>Á≤æÂáÜÂèñËâ≤ ¬∑ Êô∫ËÉΩÊ∂àÈô§ ¬∑ Â±ÄÈÉ®ÊîæÂ§ß ¬∑ Ëá™Áî±ÁºñËæë</p>
        </div>

        <div class="toolbar hidden" id="toolbar">
            <div class="tool-group">
                <button class="tool-btn active" id="eraserTool">Ê∂àÈô§Á¨î</button>
                <button class="tool-btn" id="paintTool">ÁîªÁ¨î</button>
                <button class="tool-btn" id="textTool">ÊñáÂ≠ó</button>
                <button class="tool-btn" id="colorPickerTool">Âê∏ÁÆ°</button>
                <button class="tool-btn" id="dragTool">ÊãñÂä®</button>
            </div>

            <div class="tool-group">
                <label>Á¨îÂ∑•ÂÖ∑:</label>
                <button class="tool-btn" id="penTool">Èí¢Á¨î</button>
                <button class="tool-btn" id="pencilTool">ÈìÖÁ¨î</button>
                <button class="tool-btn" id="markerTool">È©¨ÂÖãÁ¨î</button>
                <button class="tool-btn" id="brushTool">ÁîªÂà∑</button>
            </div>

            <div class="tool-group">
                <label>ÁîªÁ¨îÈ¢úËâ≤:</label>
                <div class="color-display" id="colorDisplay" style="background: #000000;">
                    <input type="color" id="colorPicker" value="#000000">
                </div>
                <div class="sampled-color-display hidden" id="sampledColorDisplay"></div>
            </div>

            <div class="tool-group" id="brushSizeControl">
                <label>ÁîªÁ¨îÂ§ßÂ∞è:</label>
                <input type="range" id="brushSize" min="1" max="50" value="20">
                <span id="brushSizeValue">20px</span>
            </div>

            <div class="tool-group hidden" id="eraserModeControl">
                <label>Ê∂àÈô§Ê®°Âºè:</label>
                <button class="tool-btn" id="autoColorMode" style="background: #28a745; color: white;">Ëá™Âä®ÂèñËâ≤</button>
                <button class="tool-btn" id="fixedColorMode">Âõ∫ÂÆöÈ¢úËâ≤</button>
            </div>

            <div class="tool-group hidden" id="textControls">
                <input type="text" id="textInput" placeholder="ËæìÂÖ•ÊñáÂ≠óÂÜÖÂÆπ" style="padding: 8px; border: 2px solid #dee2e6; border-radius: 8px;">
                <input type="number" id="fontSize" value="24" min="10" max="100" style="padding: 8px; border: 2px solid #dee2e6; border-radius: 8px; width: 80px;">
                <button class="tool-btn" id="addTextBtn">Ê∑ªÂä†ÊñáÂ≠ó</button>
            </div>
        </div>

        <div class="main-content">
            <div class="upload-area" id="uploadArea">
                <svg width="60" height="60" viewBox="0 0 24 24" fill="none" stroke="#667eea" stroke-width="2">
                    <path d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                </svg>
                <h3>ÁÇπÂáªÊàñÊãñÊãΩ‰∏ä‰º†ÂõæÁâá</h3>
                <p style="color: #6c757d;">ÊîØÊåÅ JPG, PNG, GIF Ê†ºÂºè</p>
                <input type="file" id="fileInput" accept="image/*">
            </div>

            <div class="canvas-wrapper hidden" id="canvasWrapper">
                <div class="canvas-container" id="canvasContainer">
                    <canvas id="canvas"></canvas>
                </div>
            </div>
            
            <div class="zoom-controls hidden" id="zoomControls">
                <button class="zoom-btn" id="zoomInBtn">+</button>
                <div class="zoom-level" id="zoomLevel">100%</div>
                <button class="zoom-btn" id="zoomOutBtn">‚àí</button>
                <button class="zoom-btn" id="zoomResetBtn">‚ü≤</button>
            </div>

            <div class="action-buttons hidden" id="actionButtons">
                <button class="btn btn-secondary" id="undoBtn">Êí§ÈîÄ</button>
                <button class="btn btn-secondary" id="clearBtn">Ê∏ÖÁ©∫</button>
                <button class="btn btn-primary" id="newImageBtn">Êñ∞ÂõæÁâá</button>
                <button class="btn btn-success" id="downloadBtn">‰∏ãËΩΩ</button>
            </div>
        </div>
    </div>

    <div class="color-preview" id="colorPreview">
        <canvas id="previewCanvas"></canvas>
        <div class="color-info" id="colorInfo">RGB: 0,0,0</div>
    </div>

    <div class="tips" id="tips"></div>

    <script>
        class ImageEditor {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });
                this.canvasContainer = document.getElementById('canvasContainer');
                this.canvasWrapper = document.getElementById('canvasWrapper');
                this.currentTool = 'eraser';
                this.isDrawing = false;
                this.currentColor = '#000000';
                this.brushSize = 20;
                this.fontSize = 24;
                this.originalImage = null;
                this.history = [];
                this.historyStep = -1;
                this.sampledColor = null;
                this.zoomLevel = 1;
                this.isDragging = false;
                this.dragStart = { x: 0, y: 0 };
                this.scrollStart = { x: 0, y: 0 };
                this.eraserMode = 'auto'; // 'auto' or 'fixed'
                this.hasAutoSampled = false; // Track if we've auto-sampled for current stroke
                this.textElements = []; // Store text elements
                this.selectedTextElement = null;
                this.isDraggingText = false;
                this.dragOffset = { x: 0, y: 0 };
                this.isResizing = false;
                this.penType = 'pen'; // 'pen', 'pencil', 'marker', 'brush'
                
                // Color preview
                this.colorPreview = document.getElementById('colorPreview');
                this.previewCanvas = document.getElementById('previewCanvas');
                this.previewCtx = this.previewCanvas.getContext('2d');
                this.previewCanvas.width = 150;
                this.previewCanvas.height = 150;
                
                this.initEvents();
            }

            showTip(message) {
                const tips = document.getElementById('tips');
                tips.textContent = message;
                tips.classList.add('show');
                setTimeout(() => tips.classList.remove('show'), 2000);
            }

            getAdvancedAverageColor(x, y, radius = 5) {
                // Enhanced color sampling for better accuracy on dark backgrounds
                const size = radius * 2 + 1;
                const startX = Math.max(0, Math.floor(x - radius));
                const startY = Math.max(0, Math.floor(y - radius));
                const endX = Math.min(this.canvas.width, Math.ceil(x + radius));
                const endY = Math.min(this.canvas.height, Math.ceil(y + radius));
                
                const width = endX - startX;
                const height = endY - startY;
                
                if (width <= 0 || height <= 0) {
                    return this.getPixelColor(x, y);
                }
                
                const imageData = this.ctx.getImageData(startX, startY, width, height);
                const data = imageData.data;
                
                // Use weighted average based on distance from center
                let r = 0, g = 0, b = 0;
                let totalWeight = 0;
                
                for (let py = 0; py < height; py++) {
                    for (let px = 0; px < width; px++) {
                        const idx = (py * width + px) * 4;
                        
                        // Calculate distance from center point
                        const dx = (startX + px) - x;
                        const dy = (startY + py) - y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // Weight inversely proportional to distance
                        const weight = distance <= radius ? (1 - distance / radius) : 0;
                        
                        if (weight > 0) {
                            r += data[idx] * weight;
                            g += data[idx + 1] * weight;
                            b += data[idx + 2] * weight;
                            totalWeight += weight;
                        }
                    }
                }
                
                if (totalWeight > 0) {
                    r = Math.round(r / totalWeight);
                    g = Math.round(g / totalWeight);
                    b = Math.round(b / totalWeight);
                } else {
                    // Fallback to single pixel
                    return this.getPixelColor(x, y);
                }
                
                return { r, g, b };
            }

            getPixelColor(x, y) {
                const pixel = this.ctx.getImageData(Math.floor(x), Math.floor(y), 1, 1).data;
                return {
                    r: pixel[0],
                    g: pixel[1],
                    b: pixel[2]
                };
            }

            initEvents() {
                // Upload
                const uploadArea = document.getElementById('uploadArea');
                const fileInput = document.getElementById('fileInput');
                
                uploadArea.onclick = () => fileInput.click();
                
                uploadArea.ondragover = (e) => {
                    e.preventDefault();
                    uploadArea.style.borderColor = '#667eea';
                };
                
                uploadArea.ondragleave = () => {
                    uploadArea.style.borderColor = '#dee2e6';
                };
                
                uploadArea.ondrop = (e) => {
                    e.preventDefault();
                    uploadArea.style.borderColor = '#dee2e6';
                    if (e.dataTransfer.files.length > 0) {
                        this.loadImage(e.dataTransfer.files[0]);
                    }
                };
                
                fileInput.onchange = (e) => {
                    if (e.target.files.length > 0) {
                        this.loadImage(e.target.files[0]);
                    }
                };

                // Tools
                document.getElementById('eraserTool').onclick = () => this.setTool('eraser');
                document.getElementById('paintTool').onclick = () => this.setTool('paint');
                document.getElementById('textTool').onclick = () => this.setTool('text');
                document.getElementById('colorPickerTool').onclick = () => this.setTool('colorPicker');
                document.getElementById('dragTool').onclick = () => this.setTool('drag');

                // Pen tools
                document.getElementById('penTool').onclick = () => this.setPenType('pen');
                document.getElementById('pencilTool').onclick = () => this.setPenType('pencil');
                document.getElementById('markerTool').onclick = () => this.setPenType('marker');
                document.getElementById('brushTool').onclick = () => this.setPenType('brush');

                // Eraser mode controls
                document.getElementById('autoColorMode').onclick = () => {
                    this.eraserMode = 'auto';
                    document.getElementById('autoColorMode').style.background = '#28a745';
                    document.getElementById('autoColorMode').style.color = 'white';
                    document.getElementById('fixedColorMode').style.background = 'white';
                    document.getElementById('fixedColorMode').style.color = 'black';
                    this.showTip('Ëá™Âä®ÂèñËâ≤Ê®°Âºè - ÁÇπÂáªËÉåÊôØËá™Âä®ÂèñËâ≤');
                };

                document.getElementById('fixedColorMode').onclick = () => {
                    this.eraserMode = 'fixed';
                    document.getElementById('fixedColorMode').style.background = '#28a745';
                    document.getElementById('fixedColorMode').style.color = 'white';
                    document.getElementById('autoColorMode').style.background = 'white';
                    document.getElementById('autoColorMode').style.color = 'black';
                    this.showTip('Âõ∫ÂÆöÈ¢úËâ≤Ê®°Âºè - ‰ΩøÁî®ÈÄâÂÆöÁöÑÈ¢úËâ≤');
                };

                // Color
                const colorPicker = document.getElementById('colorPicker');
                colorPicker.onchange = (e) => {
                    this.currentColor = e.target.value;
                    document.getElementById('colorDisplay').style.background = this.currentColor;
                };

                // Brush size
                const brushSizeInput = document.getElementById('brushSize');
                brushSizeInput.oninput = (e) => {
                    this.brushSize = parseInt(e.target.value);
                    document.getElementById('brushSizeValue').textContent = `${this.brushSize}px`;
                };

                // Font size
                document.getElementById('fontSize').onchange = (e) => {
                    this.fontSize = parseInt(e.target.value);
                };

                // Add text
                document.getElementById('addTextBtn').onclick = () => {
                    const text = document.getElementById('textInput').value;
                    if (text) {
                        this.addTextElement(text, 50, 50);
                        document.getElementById('textInput').value = '';
                        this.showTip('ÊñáÂ≠óÂ∑≤Ê∑ªÂä†');
                    }
                };

                // Canvas events
                this.canvas.onmousedown = (e) => this.startDraw(e);
                this.canvas.onmousemove = (e) => this.draw(e);
                this.canvas.onmouseup = () => this.stopDraw();
                this.canvas.onmouseleave = () => this.stopDraw();

                // Canvas wrapper drag events
                this.canvasWrapper.onmousedown = (e) => {
                    if (this.currentTool === 'drag' || (e.ctrlKey || e.metaKey)) {
                        this.isDragging = true;
                        this.canvasWrapper.classList.add('dragging');
                        this.dragStart = { x: e.clientX, y: e.clientY };
                        this.scrollStart = { 
                            x: this.canvasWrapper.scrollLeft, 
                            y: this.canvasWrapper.scrollTop 
                        };
                        e.preventDefault();
                    }
                };

                document.onmousemove = (e) => {
                    if (this.isDragging) {
                        const dx = this.dragStart.x - e.clientX;
                        const dy = this.dragStart.y - e.clientY;
                        this.canvasWrapper.scrollLeft = this.scrollStart.x + dx;
                        this.canvasWrapper.scrollTop = this.scrollStart.y + dy;
                    }

                    // Move text element
                    if (this.isDraggingText && this.selectedTextElement) {
                        const containerRect = this.canvasContainer.getBoundingClientRect();
                        const newX = e.clientX - containerRect.left - this.dragOffset.x;
                        const newY = e.clientY - containerRect.top - this.dragOffset.y;
                        
                        this.selectedTextElement.style.left = `${newX}px`;
                        this.selectedTextElement.style.top = `${newY}px`;
                    }

                    // Show color preview when hovering
                    if ((this.currentTool === 'eraser' || this.currentTool === 'colorPicker') && this.isOverCanvas(e)) {
                        this.showColorPreview(e);
                    } else {
                        this.colorPreview.style.display = 'none';
                    }
                };

                document.onmouseup = () => {
                    this.isDragging = false;
                    this.canvasWrapper.classList.remove('dragging');
                    
                    if (this.isDraggingText) {
                        this.isDraggingText = false;
                        this.saveHistory();
                    }
                };

                // Zoom
                document.getElementById('zoomInBtn').onclick = () => this.zoom(0.25);
                document.getElementById('zoomOutBtn').onclick = () => this.zoom(-0.25);
                document.getElementById('zoomResetBtn').onclick = () => this.zoomReset();

                // Mouse wheel zoom
                this.canvas.onwheel = (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        if (e.deltaY < 0) {
                            this.zoom(0.1);
                        } else {
                            this.zoom(-0.1);
                        }
                    }
                };

                // Actions
                document.getElementById('undoBtn').onclick = () => this.undo();
                document.getElementById('clearBtn').onclick = () => this.clear();
                document.getElementById('newImageBtn').onclick = () => fileInput.click();
                document.getElementById('downloadBtn').onclick = () => this.download();
            }

            isOverCanvas(e) {
                const rect = this.canvas.getBoundingClientRect();
                return e.clientX >= rect.left && e.clientX <= rect.right &&
                       e.clientY >= rect.top && e.clientY <= rect.bottom;
            }

            showColorPreview(e) {
                const pos = this.getMousePos(e);
                const color = this.getAdvancedAverageColor(pos.x, pos.y);
                
                // Position preview
                this.colorPreview.style.left = `${e.clientX + 20}px`;
                this.colorPreview.style.top = `${e.clientY - 75}px`;
                this.colorPreview.style.display = 'block';
                
                // Draw magnified area
                const size = 15;
                const scale = 10;
                this.previewCtx.imageSmoothingEnabled = false;
                
                const sx = Math.max(0, pos.x - size/2);
                const sy = Math.max(0, pos.y - size/2);
                
                this.previewCtx.clearRect(0, 0, 150, 150);
                this.previewCtx.drawImage(
                    this.canvas,
                    sx, sy, size, size,
                    0, 0, 150, 150
                );
                
                // Draw crosshair
                this.previewCtx.strokeStyle = '#ff0000';
                this.previewCtx.lineWidth = 1;
                this.previewCtx.beginPath();
                this.previewCtx.moveTo(75, 0);
                this.previewCtx.lineTo(75, 150);
                this.previewCtx.moveTo(0, 75);
                this.previewCtx.lineTo(150, 75);
                this.previewCtx.stroke();
                
                // Update color info
                document.getElementById('colorInfo').textContent = 
                    `RGB: ${color.r}, ${color.g}, ${color.b}`;
            }

            loadImage(file) {
                if (!file.type.startsWith('image/')) {
                    this.showTip('ËØ∑ÈÄâÊã©ÂõæÁâáÊñá‰ª∂');
                    return;
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        this.originalImage = img;
                        this.canvas.width = img.width;
                        this.canvas.height = img.height;
                        this.ctx.drawImage(img, 0, 0);
                        this.saveHistory();
                        
                        // Show editor
                        document.getElementById('uploadArea').classList.add('hidden');
                        document.getElementById('toolbar').classList.remove('hidden');
                        document.getElementById('canvasWrapper').classList.remove('hidden');
                        document.getElementById('actionButtons').classList.remove('hidden');
                        document.getElementById('zoomControls').classList.remove('hidden');
                        
                        // Center the canvas
                        this.centerCanvas();
                        this.showTip('ÂõæÁâáÂ∑≤Âä†ËΩΩÔºåÂèØ‰ª•ÂºÄÂßãÁºñËæë');
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }

            centerCanvas() {
                setTimeout(() => {
                    const wrapper = this.canvasWrapper;
                    const container = this.canvasContainer;
                    wrapper.scrollLeft = (container.offsetWidth - wrapper.clientWidth) / 2;
                    wrapper.scrollTop = (container.offsetHeight - wrapper.clientHeight) / 2;
                }, 100);
            }

            setTool(tool) {
                this.currentTool = tool;
                this.hasAutoSampled = false; // Reset auto-sample flag when changing tools
                this.deselectAllText();
                
                document.querySelectorAll('.tool-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                
                // Hide all tool-specific controls first
                document.getElementById('brushSizeControl').classList.add('hidden');
                document.getElementById('textControls').classList.add('hidden');
                document.getElementById('eraserModeControl').classList.add('hidden');
                
                if (tool === 'eraser') {
                    document.getElementById('eraserTool').classList.add('active');
                    document.getElementById('brushSizeControl').classList.remove('hidden');
                    document.getElementById('eraserModeControl').classList.remove('hidden');
                    this.canvas.style.cursor = 'crosshair';
                    this.canvasWrapper.style.cursor = 'default';
                    
                    if (this.eraserMode === 'auto') {
                        this.showTip('Ê∂àÈô§Á¨î - ÁÇπÂáªËÉåÊôØËá™Âä®ÂèñËâ≤');
                    } else {
                        this.showTip('Ê∂àÈô§Á¨î - ‰ΩøÁî®Âõ∫ÂÆöÈ¢úËâ≤');
                    }
                } else if (tool === 'paint') {
                    document.getElementById('paintTool').classList.add('active');
                    document.getElementById('brushSizeControl').classList.remove('hidden');
                    this.canvas.style.cursor = 'crosshair';
                    this.canvasWrapper.style.cursor = 'default';
                    this.showTip('ÁîªÁ¨î - ‰ΩøÁî®ÈÄâÂÆöÈ¢úËâ≤ÁªòÂà∂');
                } else if (tool === 'text') {
                    document.getElementById('textTool').classList.add('active');
                    document.getElementById('textControls').classList.remove('hidden');
                    this.canvas.style.cursor = 'text';
                    this.canvasWrapper.style.cursor = 'default';
                    this.showTip('ÁÇπÂáªÊ∑ªÂä†ÊñáÂ≠óÔºåÂèåÂáªÁºñËæëÊñáÂ≠ó');
                } else if (tool === 'colorPicker') {
                    document.getElementById('colorPickerTool').classList.add('active');
                    this.canvas.style.cursor = 'crosshair';
                    this.canvasWrapper.style.cursor = 'default';
                    this.showTip('ÁÇπÂáªÂê∏ÂèñÈ¢úËâ≤');
                } else if (tool === 'drag') {
                    document.getElementById('dragTool').classList.add('active');
                    this.canvas.style.cursor = 'grab';
                    this.canvasWrapper.style.cursor = 'grab';
                    this.showTip('ÊãñÂä®Êü•ÁúãÂõæÁâá‰∏çÂêåÂå∫Âüü');
                }
            }

            setPenType(type) {
                this.penType = type;
                
                // Update pen tool buttons
                document.querySelectorAll('#penTool, #pencilTool, #markerTool, #brushTool').forEach(btn => {
                    btn.classList.remove('pen-active');
                });
                
                document.getElementById(type + 'Tool').classList.add('pen-active');
                
                // Update brush settings based on pen type
                switch(type) {
                    case 'pen':
                        this.ctx.lineCap = 'round';
                        this.ctx.lineJoin = 'round';
                        this.ctx.globalAlpha = 1.0;
                        this.showTip('Èí¢Á¨î - Á≤æÁ°ÆÁªòÂà∂');
                        break;
                    case 'pencil':
                        this.ctx.lineCap = 'round';
                        this.ctx.lineJoin = 'round';
                        this.ctx.globalAlpha = 0.8;
                        this.showTip('ÈìÖÁ¨î - ÊüîÂíåÁªòÂà∂');
                        break;
                    case 'marker':
                        this.ctx.lineCap = 'square';
                        this.ctx.lineJoin = 'round';
                        this.ctx.globalAlpha = 0.6;
                        this.showTip('È©¨ÂÖãÁ¨î - ÂçäÈÄèÊòéÊ†áËÆ∞');
                        break;
                    case 'brush':
                        this.ctx.lineCap = 'round';
                        this.ctx.lineJoin = 'round';
                        this.ctx.globalAlpha = 0.9;
                        this.showTip('ÁîªÂà∑ - ÊüîÂíåÁ¨îËß¶');
                        break;
                }
            }

            getMousePos(e) {
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / (rect.width / this.zoomLevel);
                const scaleY = this.canvas.height / (rect.height / this.zoomLevel);
                
                return {
                    x: (e.clientX - rect.left) * scaleX / this.zoomLevel,
                    y: (e.clientY - rect.top) * scaleY / this.zoomLevel
                };
            }

            startDraw(e) {
                if (this.currentTool === 'drag') return;
                
                const pos = this.getMousePos(e);
                
                if (this.currentTool === 'text') {
                    // Add text at clicked position
                    const text = document.getElementById('textInput').value;
                    if (text) {
                        this.addTextElement(text, pos.x, pos.y);
                        document.getElementById('textInput').value = '';
                        this.showTip('ÊñáÂ≠óÂ∑≤Ê∑ªÂä†');
                    } else {
                        this.showTip('ËØ∑ÂÖàËæìÂÖ•ÊñáÂ≠óÂÜÖÂÆπ');
                    }
                    return;
                }
                
                if (this.currentTool === 'eraser') {
                    // Check eraser mode
                    if (this.eraserMode === 'auto' && !this.hasAutoSampled) {
                        // Auto sample color from clicked position
                        const color = this.getAdvancedAverageColor(pos.x, pos.y, 7);
                        this.sampledColor = `rgb(${color.r}, ${color.g}, ${color.b})`;
                        this.hasAutoSampled = true;
                        
                        // Show sampled color
                        const sampledDisplay = document.getElementById('sampledColorDisplay');
                        sampledDisplay.style.background = this.sampledColor;
                        sampledDisplay.classList.remove('hidden');
                        
                        this.showTip(`Â∑≤Ëá™Âä®ÂèñËâ≤: RGB(${color.r}, ${color.g}, ${color.b})`);
                    } else if (this.eraserMode === 'fixed') {
                        // Use the selected color
                        this.sampledColor = this.currentColor;
                        
                        // Show current color as sampled
                        const sampledDisplay = document.getElementById('sampledColorDisplay');
                        sampledDisplay.style.background = this.sampledColor;
                        sampledDisplay.classList.remove('hidden');
                    }
                    
                    this.isDrawing = true;
                    this.ctx.strokeStyle = this.sampledColor;
                    this.ctx.lineWidth = this.brushSize;
                    this.ctx.lineCap = 'round';
                    this.ctx.lineJoin = 'round';
                    this.ctx.beginPath();
                    this.ctx.moveTo(pos.x, pos.y);
                    
                } else if (this.currentTool === 'paint') {
                    // Paint tool - always use selected color
                    this.isDrawing = true;
                    this.ctx.strokeStyle = this.currentColor;
                    this.ctx.lineWidth = this.brushSize;
                    
                    // Apply pen type settings
                    this.setPenType(this.penType);
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(pos.x, pos.y);
                    
                } else if (this.currentTool === 'colorPicker') {
                    const color = this.getAdvancedAverageColor(pos.x, pos.y, 5);
                    const hex = '#' + [color.r, color.g, color.b].map(x => x.toString(16).padStart(2, '0')).join('');
                    this.currentColor = hex;
                    document.getElementById('colorPicker').value = hex;
                    document.getElementById('colorDisplay').style.background = hex;
                    this.showTip(`È¢úËâ≤Â∑≤Âê∏Âèñ: ${hex}`);
                }
            }

            draw(e) {
                if (!this.isDrawing || (this.currentTool !== 'eraser' && this.currentTool !== 'paint')) return;
                const pos = this.getMousePos(e);
                this.ctx.lineTo(pos.x, pos.y);
                this.ctx.stroke();
            }

            stopDraw() {
                if (this.isDrawing) {
                    this.isDrawing = false;
                    this.hasAutoSampled = false; // Reset for next stroke
                    this.saveHistory();
                }
            }

            addTextElement(text, x, y) {
                const textElement = document.createElement('div');
                textElement.className = 'text-element';
                textElement.style.left = `${x}px`;
                textElement.style.top = `${y}px`;
                textElement.style.color = this.currentColor;
                textElement.style.fontSize = `${this.fontSize}px`;
                textElement.style.fontFamily = 'Arial';
                textElement.textContent = text;
                
                // Add resize handle
                const resizeHandle = document.createElement('div');
                resizeHandle.className = 'resize-handle';
                textElement.appendChild(resizeHandle);
                
                // Add event listeners
                textElement.addEventListener('mousedown', (e) => this.handleTextMouseDown(e));
                textElement.addEventListener('dblclick', (e) => this.handleTextDoubleClick(e));
                resizeHandle.addEventListener('mousedown', (e) => this.handleResizeMouseDown(e));
                
                this.canvasContainer.appendChild(textElement);
                this.textElements.push(textElement);
                this.saveHistory();
            }

            handleTextMouseDown(e) {
                if (e.target.classList.contains('resize-handle')) return;
                
                e.stopPropagation();
                e.preventDefault();
                
                this.selectTextElement(e.currentTarget);
                this.isDraggingText = true;
                
                const rect = e.currentTarget.getBoundingClientRect();
                const containerRect = this.canvasContainer.getBoundingClientRect();
                
                this.dragOffset = {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }

            handleTextDoubleClick(e) {
                e.stopPropagation();
                e.preventDefault();
                
                const textElement = e.currentTarget;
                this.editTextElement(textElement);
            }

            handleResizeMouseDown(e) {
                e.stopPropagation();
                e.preventDefault();
                
                this.isResizing = true;
                this.selectedTextElement = e.currentTarget.parentElement;
                
                document.addEventListener('mousemove', this.handleResizeMouseMove.bind(this));
                document.addEventListener('mouseup', this.handleResizeMouseUp.bind(this));
            }

            handleResizeMouseMove(e) {
                if (!this.isResizing || !this.selectedTextElement) return;
                
                const rect = this.selectedTextElement.getBoundingClientRect();
                const containerRect = this.canvasContainer.getBoundingClientRect();
                
                const newWidth = e.clientX - rect.left;
                const newHeight = e.clientY - rect.top;
                
                // Calculate new font size based on resize
                const currentFontSize = parseInt(this.selectedTextElement.style.fontSize);
                const newFontSize = Math.max(10, Math.min(100, currentFontSize + (newWidth - rect.width) / 2));
                
                this.selectedTextElement.style.fontSize = `${newFontSize}px`;
            }

            handleResizeMouseUp() {
                this.isResizing = false;
                document.removeEventListener('mousemove', this.handleResizeMouseMove.bind(this));
                document.removeEventListener('mouseup', this.handleResizeMouseUp.bind(this));
                this.saveHistory();
            }

            selectTextElement(element) {
                this.deselectAllText();
                element.classList.add('selected');
                this.selectedTextElement = element;
            }

            deselectAllText() {
                this.textElements.forEach(element => {
                    element.classList.remove('selected', 'editing');
                });
                this.selectedTextElement = null;
            }

            editTextElement(element) {
                element.classList.add('editing');
                const currentText = element.textContent;
                
                const input = document.createElement('input');
                input.type = 'text';
                input.value = currentText;
                input.style.cssText = `
                    position: absolute;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    border: 2px solid #28a745;
                    border-radius: 4px;
                    padding: 5px;
                    font-size: ${element.style.fontSize};
                    font-family: ${element.style.fontFamily};
                    color: ${element.style.color};
                    background: white;
                    outline: none;
                `;
                
                element.innerHTML = '';
                element.appendChild(input);
                input.focus();
                input.select();
                
                const finishEdit = () => {
                    const newText = input.value.trim();
                    if (newText) {
                        element.textContent = newText;
                        element.style.color = this.currentColor;
                        element.style.fontSize = `${this.fontSize}px`;
                        
                        // Re-add resize handle
                        const resizeHandle = document.createElement('div');
                        resizeHandle.className = 'resize-handle';
                        element.appendChild(resizeHandle);
                        resizeHandle.addEventListener('mousedown', (e) => this.handleResizeMouseDown(e));
                        
                        this.saveHistory();
                    } else {
                        element.remove();
                        this.textElements = this.textElements.filter(el => el !== element);
                    }
                };
                
                input.addEventListener('blur', finishEdit);
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        finishEdit();
                    } else if (e.key === 'Escape') {
                        element.textContent = currentText;
                        element.classList.remove('editing');
                        
                        // Re-add resize handle
                        const resizeHandle = document.createElement('div');
                        resizeHandle.className = 'resize-handle';
                        element.appendChild(resizeHandle);
                        resizeHandle.addEventListener('mousedown', (e) => this.handleResizeMouseDown(e));
                    }
                });
            }

            zoom(delta) {
                const oldZoom = this.zoomLevel;
                this.zoomLevel = Math.max(0.25, Math.min(4, this.zoomLevel + delta));
                
                // Update container transform
                this.canvasContainer.style.transform = `scale(${this.zoomLevel})`;
                
                // Adjust container size to prevent clipping
                const newWidth = this.canvas.width * this.zoomLevel;
                const newHeight = this.canvas.height * this.zoomLevel;
                this.canvasContainer.style.width = `${newWidth}px`;
                this.canvasContainer.style.height = `${newHeight}px`;
                
                // Update zoom display
                document.getElementById('zoomLevel').textContent = `${Math.round(this.zoomLevel * 100)}%`;
                
                // Adjust scroll to keep center point
                if (oldZoom !== this.zoomLevel) {
                    const wrapper = this.canvasWrapper;
                    const zoomRatio = this.zoomLevel / oldZoom;
                    const centerX = wrapper.scrollLeft + wrapper.clientWidth / 2;
                    const centerY = wrapper.scrollTop + wrapper.clientHeight / 2;
                    
                    wrapper.scrollLeft = centerX * zoomRatio - wrapper.clientWidth / 2;
                    wrapper.scrollTop = centerY * zoomRatio - wrapper.clientHeight / 2;
                }
                
                this.showTip(`Áº©Êîæ: ${Math.round(this.zoomLevel * 100)}%`);
            }

            zoomReset() {
                this.zoomLevel = 1;
                this.canvasContainer.style.transform = 'scale(1)';
                this.canvasContainer.style.width = `${this.canvas.width}px`;
                this.canvasContainer.style.height = `${this.canvas.height}px`;
                document.getElementById('zoomLevel').textContent = '100%';
                this.centerCanvas();
                this.showTip('ÊÅ¢Â§çÂéüÂßãÂ§ßÂ∞è');
            }

            saveHistory() {
                this.historyStep++;
                this.history = this.history.slice(0, this.historyStep);
                this.history.push(this.canvas.toDataURL());
            }

            undo() {
                if (this.historyStep > 0) {
                    this.historyStep--;
                    const img = new Image();
                    img.onload = () => {
                        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                        this.ctx.drawImage(img, 0, 0);
                    };
                    img.src = this.history[this.historyStep];
                    this.showTip('Â∑≤Êí§ÈîÄ');
                }
            }

            clear() {
                if (this.originalImage) {
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    this.ctx.drawImage(this.originalImage, 0, 0);
                    this.saveHistory();
                    this.sampledColor = null;
                    document.getElementById('sampledColorDisplay').classList.add('hidden');
                    this.showTip('Â∑≤Ê∏ÖÁ©∫ÁºñËæë');
                }
            }

            download() {
                // Create a temporary canvas to include text elements
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = this.canvas.width;
                tempCanvas.height = this.canvas.height;
                
                // Draw the main canvas
                tempCtx.drawImage(this.canvas, 0, 0);
                
                // Draw text elements
                this.textElements.forEach(textElement => {
                    if (!textElement.classList.contains('editing')) {
                        const rect = textElement.getBoundingClientRect();
                        const containerRect = this.canvasContainer.getBoundingClientRect();
                        
                        const x = (rect.left - containerRect.left) / this.zoomLevel;
                        const y = (rect.top - containerRect.top) / this.zoomLevel + parseInt(textElement.style.fontSize);
                        
                        tempCtx.fillStyle = textElement.style.color;
                        tempCtx.font = `${textElement.style.fontSize} ${textElement.style.fontFamily}`;
                        tempCtx.fillText(textElement.textContent, x, y);
                    }
                });
                
                const link = document.createElement('a');
                link.download = `edited_${Date.now()}.png`;
                link.href = tempCanvas.toDataURL();
                link.click();
                this.showTip('ÂõæÁâáÂ∑≤‰∏ãËΩΩ');
            }
        }

        // Start the editor
        const editor = new ImageEditor();
        
        // Initialize pen tool
        editor.setPenType('pen');
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Ctrl/Cmd + Z for undo
            if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                e.preventDefault();
                editor.undo();
            }
            // Spacebar for temporary drag mode
            if (e.key === ' ' && !e.target.matches('input, textarea')) {
                e.preventDefault();
                editor.setTool('drag');
            }
            // Number keys for quick zoom
            if (e.key >= '1' && e.key <= '4' && (e.ctrlKey || e.metaKey)) {
                e.preventDefault();
                const zoomLevels = [0.25, 0.5, 1, 2];
                const targetZoom = zoomLevels[parseInt(e.key) - 1];
                editor.zoomLevel = 0;
                editor.zoom(targetZoom);
            }
        });
        
        // Release spacebar drag
        document.addEventListener('keyup', (e) => {
            if (e.key === ' ' && editor.currentTool === 'drag') {
                editor.setTool('eraser');
            }
        });
    </script>
</body>
</html>